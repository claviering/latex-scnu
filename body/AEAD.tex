\subsection{对称加密算法}

% 对称密码通常有两种主要形式：流密码和分组密码。流密码采用固定大小的密钥并使用它来创建任意长度的伪随机数据流，称为密钥流。 要使用流密码进行加密，可以通过将密钥流的每个位与消息的相应位进行异或来获取消息并将其与密钥流合并。当解密时候，使用加密后的消息与密钥流进行异或操作，恢复明文。 纯流密码的加密有RC4，和ChaCha20，TLS 1.3 已经删除了 RC4。分组密码与流密码不同，因为它只加密固定大小的消息。 如果要加密比块大小更短或更长的消息，则必须执行一些额外的操作，对于较短的消息，必须在消息的末尾添加一些额外的数据，作为填充。 对于较长的消息，将消息拆分为密码算法可以加密的合适大小的块，最后再组合起来。或者，可以通过使用块密码加密计数器序列并将其用作流来将块密码转换为流密码。 这称为计数器模式。 使用分组密码加密任意长度数据的一种流行方式是称为密码块链接（CBC）的模式。为了防止攻击者篡改数据，加密是不够的。 数据还需要受到完整性保护。 对于CBC模式密码，使用消息验证代码来完成消息完整性。 强的MAC具有以下特性：除非你知道密钥，否则找到与输入匹配的MAC值几乎是不可能的。 有两种方法可以组合MAC和CBC模式加密后的密文。 先加密然后计算密文的 MAC 附加到密文末尾，或者先计算明文的 MAC，然后把 MAC 附加到明文的末尾，然后加密明文和 MAC。 在TLS中，选择了后者，MAC-then-Encrypt，结果证明是错误的选择。导致 BEAST 漏洞，以及一系列填充 oracle 漏洞，例如 Lucky 13 和 Lucky Microseconds。AEAD 是 TLS 1.3 唯一保留的对称加密算法。它将完整性校验和数据加密两种功能集成在同一算法中完成。AEAD也是一种范式，不是一种具体的加密标准. AEAD是指同时包含了加密和完整性哈希的加密算法，可以由单纯的CBC和SHA1组合而成，也可以直接是GCM这种内涵了加密算法和MAC算法的范式套件直接组成。GCM的完全胜出，使得AEAD的发展方向非常明朗。GCM是一种认证加密方式，不是一种特定的加密算法。GCM 伽罗瓦/计数器模式 G就是指GMAC，C就是指CTR。 GCM 中使用 AES 等 128 位比特分组密码的 CTR 模式，并使用一个反复进行加法和乘法运算的散列函数来计算 MAC 值。CTR 模式加密与 MAC 值的计算使用的是相同密钥，所以密钥管理很方便。GCM可以提供对消息的加密性，完整性和认证性，另外，它还可以提供附加消息的完整性校验。执行对称加密和解密的算法称为对称密码。

% ChaCha20-Poly1305的主要竞争对手是基于AES-GCM的密码套件。最广泛使用的AES-GCM使用带有128位密钥的AES，但在安全性方面，AES-256与ChaCha20更具可比性。实际上，这意味着许多连接永远不会达到TLS记录的最大大小（16KB），而是使用明显更小的记录（低于1400字节）。随着连接的进行，记录大小会动态增长，扩展到大约4KB，最终扩展到16KB。大多数消息也不能精确地适合记录，并且所有大小都是可能的。

% 与AES-CTR类似，ChaCha20是一种流密码。

TLS 1.3 中使用的 AEAD 算法有 AES-256-GCM，AES-128-GCM 和 ChaCha20-Poly1305，AEAD 算法操作有4个输入：1. 要加密的明文、2. 密钥、3. 一个独特的初始化值 - IV。 在使用相同密钥调用加密操作之间必须是唯一的，否则密码的保密性将完全受到损害、4. 可选部分，一些其他非秘密的附加数据，此数据不会被加密，但会进行身份验证。在数据被加密之后，加密算法使用密钥（以及可选地加入IV）来生成辅助密钥。 辅助密钥用于生成AD的密钥散列，密文和每个密钥的各个长度。 ChaCha20-Poly1305中使用的散列函数是Poly1305，而在AES-GCM中，散列函数用的是GHASH。最后一步是获取哈希值并对其进行加密，生成最终的MAC（消息认证码）并将其附加到密文。解密操作与加密相反。 它采用相同的密钥和IV并生成密文和AD的MAC，类似于加密的方式。 然后它读取密文之后附加的MAC，并比较两者。 MAC值有任何差异都意味着密文或AD被篡改，并且它们应该被认为不安全而丢弃。如果两者匹配，则执行解密操作，恢复原始明文。AEAD将两种算法 - 加密算法和MAC算法组合成一个算法，具有可证明的安全性。当 AES\_GCM 被破解时，ChaCha20-Poly305 是一种候选算法。数字20表示它总共重复20轮加密操作。它从递增的计数器生成伪随机比特流，然后用明文对该流进行“异或”以对其进行加密（或者用密文进行“异或”以解密）。 

不需要提前知道明文来生成流，所以这种方法既可以非常高效又可以并行化。 ChaCha20是一个256位密钥加密算法，Poly1305可以与任何加密或未加密的消息一起使用，以生成密钥认证令牌。 这种令牌的目的是保证给定消息的完整性。对于 AES 块加密算法，在某些硬件上使用 AES-NI 加速指令，可以运行非常快，如果没用加速指令，单纯使用软件运行，性能会很低。而流密码 ChaCha20，则相反，软件实现性能很高，由于大部分移动设备没有 AES-NI 加速指令，运行 AES 会比较慢。ChaCha20-Poly1305 流密码算法来了，除了安全性外，它在移动设备上运行的性能较高。

% AEAD也有一定局限性：使用同一密钥加密的明文达到一定长度后，就不能再保证密文的安全性。因此，TLS 1.3中引入了密钥更新机制，一方可以（通常是服务器）向另一方发送Key Update（KU）报文，对方收到报文后对当前会话密钥再使用一次HKDF，计算出新的会话密钥，使用该密钥完成后续的通信。

CHACHA20 流加密算法。其原理和实现大致可以分成如下两个步骤：

1.基于输入的对称秘钥生成足够长度的keystream

2.将上述keystream和明文进行按位异或，得到密文

ChaCha密钥为256位（K =（k0，k1，k2，k3，k4，k5，k6，k7，以32位密钥运行。这个输出块为512位，用于密钥流（Z），以及 与明文流进行异或运算。初始状态包含16个32位值，组成 4x4 矩阵，具有128位的常量（0x61707865,0x3320646e，0x79622d32,0x6b206574）256位的密钥（k0，k1，k2，k3，k4，k5，k6，k7），32位的计数器（c）和 96位的 nonce（N0，N1，N3）。ChaCha20一共进行20轮加密操作，10轮列操作，10轮对角线操作。初始化矩阵加 20 轮操作之后的矩阵等到密钥流矩阵，和明文进行异或运算得出密文。由于计数器是32位，理论上可以生成 2 \^ 512 bit（256GB）的密钥流，所以一般长度的信息加密完全足够。解密操作和加密操作一样，接收方与发送方生成一样密钥流矩阵，与密文异或解密得到明文。

ChaCha20-Poly1305 优势\cite{7507408}，\cite{7927078}
Google 推出新的加密套件并在所有移动端的 Chrome 浏览器上优先使用原因：
ChaCha20-Poly1305 避开了现有发现的所有安全漏洞和攻击；
ChaCha20-Poly1305 针对移动端设备大量使用的ARM芯片做了优化，能够充分利用 ARM 向量指令，在移动设备上加解密速度更快、更省电；Poly1305 输出只有 16字节，更加节省带宽

\newpage