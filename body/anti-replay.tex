\subsection{重放攻击原理}

当攻击者窃听并且截获安全网络通信，然后欺骗性地延迟或重新发送被攻击者在通信中已经使用过的正确消息，消息被正确加密，服务器接收到之后正确解密，就会发生重放攻击。重放攻击的另一个危害是，攻击者在从网络捕获消息后甚至不需要使用高级技能来解密消息。只需重新发送整个消息内容，攻击就可以成功。除非服务器有缓解措施，否则受重放攻击的服务器会将攻击过程视为正确合法的消息。重放攻击的一个例子是消息由攻击者重放发送到网络，该消息先前由服务器授权用户发送。尽管消息可能已加密且攻击者可能无法获得实际密钥解密消息，但重放有效数据或登录消息可帮助攻击者获得对服务器的授权访问。重放攻击可以通过重放身份验证消息来访问资源，并且可能会混淆目标服务器。

攻击者虽然不知道 0-RTT 发送 Early Data 的意义，但可能知道它的意义，TLS 1.3 1-RTT 加密数据为了防止重放攻击，使用 AEAD 加密数据块的时候使用的 Nonce 都不同。在 0-RTT 的握手方式中，第一个加密的应用层数据和握手数据一起发送给服务器，对于第一个数据的防重放，服务器只能完全靠客户端发来的数据来判断是否重放，如果客户端发送的数据完全由自己生成，没有包含服务器参与的标识，那么这份数据是无法判断是否为重放数据包。TLS 1.3 给了一个思路来解决 0-RTT 跨连接重放的问题：在服务器保存一个跨连接的全局状态，每新建一个连接都更新这个全局状态，那么 0-RTT 握手带来的第一个应用层数据也可以由这个跨连接的全局状态来判断是否重放。

针对 0-RTT 的重放攻击，攻击方式有两种：1. 通过简单拦截、复制 0-RTT 数据并发送来进行重放攻击。攻击者截获 0-RTT 消息并且保存下来，将整个 0-RTT 消息转发到服务器。服务器正确处理 PSK 解密出 Early Data，服务器执行响应的操作处理请求。2. 多个服务器负载均衡时，不维护一致的服务器状态，利用客户端重试行为使服务器接收多个 0-RTT 消息的副本。攻击者可以通过恶意 Javascript 代码在客户端的浏览器上重复发送 0-RTT 请求，在负载均衡时，将来自客户端的请求平均的转发到每个后台服务处理，没有共享 0-RTT 有效状态时，会导致一个或者多个服务重复处理 0-RTT 中数据请求，比如发生了多次转账操作。

\subsection{防御一般性重放攻击}

2012 年 Lan Sun 和 Zhao Luo 等人\cite{6295193}提出了基于分组的算法防止重放攻击。防止重放攻击的最优技术之一是使用带有时间戳的服务器数字签名，可用于避免重放攻击的另一种技术是创建时间绑定的随机会话密钥。每个请求的一次性密钥也有助于防止重放攻击，并且经常用于银行上金钱的操作。用于对抗重放攻击的其他技术包括消息排序和不接受重复消息。
\begin{enumerate}
  \item 使用一次性密码:
  
    一次性密码类似于会话令牌，因为密码在使用后或在很短的时间后到期。 除会话外，它们还可用于验证单个事务。 这些也可以在身份验证过程中使用，以帮助在彼此通信的双方之间建立信任。

  \item 使用会话令牌标记加密消息:
  
    因为为客户端每次连接都会创建了唯一的随机会话令牌，因此先前的连接变得更难以复制。在这种情况下，攻击者将无法执行重播，因为在新的连接中，会话令牌会发生变化。服务器向客户端发送一次性令牌，客户端用它来转加密用户密码并将结果发送给服务器。例如，她将使用令牌来计算会话令牌的哈希函数，并将其附加到要使用的密码。同时，服务器使用会话令牌执行相同的计算。当且仅当客户端和服务器的值匹配时，登录成功。现在假设攻击者已经获取此会话令牌并尝试在另一个会话中使用它。 服务器会发送一个不同的会话令牌，当攻击者回复服务器重放的值时，它将与服务器的计算不同，因此服务器知道不是客户端正常的请求。会话令牌应随机选择（通常使用伪随机函数）。否则，攻击者可能会伪装成服务器，发送一些猜测的会话令牌，并欺骗客户端使用该令牌。然后，攻击者可以在未来某个时候重放消息（当先前猜测的会话令牌由服务器实际产生时），并且服务器将接受该重放消息。

  \item 时间戳:

    时间戳是防止重放攻击的另一种方法。应使用安全协议实现时间同步。 例如，服务器定期广播他的时钟上的时间。 当客户端想要向服务器发送消息时，在消息中包括对时间的最佳估计，该消息是被认证的。 服务器只接受时间戳在合理范围误差内的消息。 这种方案的优点是服务器不需要生成（伪）随机数，并且客户端不需要向服务器请求随机数。缺点是攻击者能足够快地执行重播攻击，服务器在合理时间限制内接收到，则会攻击可以成功。

\end{enumerate}

\subsection{防御零轮往返时长协议重放攻击}

参考 Marc Fischlin 和 Felix Günther\cite{7961952} 研究重放攻击下0-RTT的安全性，以及 RFC 中提到的抗重放攻击方法。编程实现相关方法措施抵抗重放攻击。第一个措施是检查 Ticker 是否过期。服务器在创建 Ticker 时候可以设置较短的有效期，保存创建此 Ticker 的时间，在 Redis 数据库中，以 Ticker 作为 Key，创建时间作为 Value 保存。接收到客户端发来的 Ticker 时，从 Redis 数据中获取创建时间，然后检查是否过期了，如果过期了就不处理 Early Data 中的数据，并且将握手降级到 1-RTT。服务器发送的 NewSessionTicket 中的 Ticket Lifetime 有效期最多是7天，但为了减少有效期，选择设置有效期为 5 分钟，使用时候单位转为秒，并且发送 Ticket Age Add 用于计算客户端发送的 Obfuscated Ticket Age 过期时间，计算为 Ticket Lifetime (转化为毫秒为单位) + Ticket Age Add 模 $2^{23}$。服务器接收到 0-RTT 时候，使用 Obfuscated Ticket Age - Ticket Age Add 计算出 Ticker 的有效期 Ticker Age，和数据库中取出的 Ticker 创建时间做比较。如果 Ticker Age 在 Ticket Lifetime 内，服务器则接受 0-RTT，反之拒绝 0-RTT。可以在计算的时候加上往返延迟，减少误差。

第二个措施是检查 Ticker 是否被使用。服务器在为每一个客户端发送的 NewS\-essionTicket 中的 Ticker 是由 Ticket Nonce 进过 HKDF 生成的，保证了不同客户端拥有不同的 Ticker，在服务器生成 Ticker 的同时，把 Ticker 作为 Key，1 作为 Value 保存到 Redis 数据库，保存所有未使用的 Ticker。当客户端使用 0-RTT 握手的时候，服务器通过的 的 Binder 验证之后，还要去数据库检查 Ticker 是否存在，如果客户端发送的是未使用的 Ticker 一定能在 Redis 数据库中找到对应数据，然后接受 0-RTT。并且删除 Redis 对应的 Ticker。如果重放 0-RTT，虽然能通过服务器的 Binder 检查，但是在查找 Redis 数据库时却返回为空，因此拒绝重放的 0-RTT，使用 ClientHello 中的 Key Share 参数进行 1-RTT 握手。

第三个措施，结合第一个和第二个措施做优化。服务器在生成 Ticker 保存到 Redis 数据库中的时候，设置 Redis 数据库中保存 Ticker 的超时时间，并且超时时间等于 Ticker Lifetime。当 Ticker 过期后，能及时自动删除数据库中过期的 Ticket，避免过多占用数据库。服务器接收到 0-RTT，首先检查 Ticker 是否过期，如果过期，则数据库会自动删除对应的 Ticker，因此查询 Ticker 失败，服务器可以拒绝此 0-RTT 请求，查询数据库不为空，则返回对应 Ticker 的创建时间，表明没有过期，进一步检查 Binder 是否正确。

第四个措施是服务器只接受幂等性的 0-RTT 请求。服务器收到 0-RTT 时，从 Resumption secret 导出 Early Data 的解密密钥，解密 Early Data 然后判断是否是非幂等性的请求，判断是否满足幂等性的请求的要求，如果不是，服务器将会拒绝 0-RTT，非幂等请求才能允许，比如是一个 GET 请求打开一个网站。这时使用 0-RTT 发送 GET 请求，可以网页可以更快展示出来，大多数的 GET 请求都是请求服务器上的静态资源，就算攻击者重放了 GET 请求的 0-RTT 数据包，最多只能使客户端发生页面的刷新，并不会服务器的对数据库进行操作和其重复请求操作。

第五个措施是：添加 Early Data 请求头，通知后端服务。Nginx 反向代理可以设置 proxy\_set\_header Early-Data \$ssl\_early\_data; 由后端服务根据具体情况判断是否愿意接受这个 0-RTT 请求。如果拒接，后端服务拒绝 0-RTT数据响应，并且发送 425 Too Early [rfc8470] 状态码。

第六个措施是客户端在 0-RTT 中发送自己认为是安全的请求，为了保证攻击者重放数据也得不到有效信息。非幂等请求通过 0-RTT 发送是不安全的，因为攻击者可以重放它们，但即使是幂等请求也可能不安全，有可能从返回信息中得到什么。具体应用程序可以控制，但浏览器一般认为通过 0-RTT 发送所有数据。在 Chrome 中，在握手确认之前仅发送 GET 请求。

通过共享数据库可以防止第二种攻击，以保证集群中的系统最多接受一次 0-RTT 数据，最多响应一次。使用 Ticker 共享，多个服务器使用同一个 Redis 数据库保存 Ticker，维护 Ticker 在分布式系统的的唯一性，群集中的服务器都将生成的 Ticker 保存到公共 Redis 数据库，统一维护 Ticker 唯一性和有效期。当集群中某一台服务器接收到 0-RTT 的时候，首先去查询数据库对应的 Ticker，如果是第一次发送并非重放攻击，并且此 Ticker 没有过期，下一步检查 Binder 的正确性。当攻击者重放 0-RTT 的时候，负载均衡会将请求分发都没个后台服务，当其中一个请求查询 Ticker 时候，可以设置锁定数据库，防止重复读取合法的 Ticker。


% 设置 max\_early\_data\_size 大小，以允许客户端发送指定大小的 early data
% max\_early\_data\_size：使用此票证时允许客户端发送的最大0-RTT数据量（以字节为单位）。 仅计算应用数据有效载荷（即，明文但不填充或内部内容类型字节）。 接收超过max\_early\_data\_size字节的0-RTT数据的服务器应该使用“unexpected\_message”警报终止连接。